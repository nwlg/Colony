// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: HibernateEntity.vsl in andromda-hibernate-cartridge.
//
package es.pode.planificador.negocio.dominio;

/**
 * <p>
 * Entidad que nos sirve de auditoría inicándonos los parámetros
 * del trabajo ejecutado
 * </p>
 */
public abstract class TareaEjecutada
    implements java.io.Serializable
{
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 4594766800734394733L;

    private java.lang.String descripcion;

  /**
   * <p>
   * Descripción de la tarea ejecutada (trabajo)
   * </p>
   * @return java.lang.String
   */
    public java.lang.String getDescripcion()
    {
        return this.descripcion;
    }

  /**
   * <p>
   * Descripción de la tarea ejecutada (trabajo)
   * </p>
   *  @param descripcion  Descripción de la tarea ejecutada (trabajo) 
   */
    public void setDescripcion(java.lang.String descripcion)
    {
        this.descripcion = descripcion;
    }
    private java.lang.String trabajo;

  /**
   * <p>
   * Nombre del trabajo ejecutado
   * </p>
   * @return java.lang.String
   */
    public java.lang.String getTrabajo()
    {
        return this.trabajo;
    }

  /**
   * <p>
   * Nombre del trabajo ejecutado
   * </p>
   *  @param trabajo  Nombre del trabajo ejecutado 
   */
    public void setTrabajo(java.lang.String trabajo)
    {
        this.trabajo = trabajo;
    }
    private java.lang.String grupoTrabajo;

  /**
   * <p>
   * Grupo del trabajo ejecutado
   * </p>
   * @return java.lang.String
   */
    public java.lang.String getGrupoTrabajo()
    {
        return this.grupoTrabajo;
    }

  /**
   * <p>
   * Grupo del trabajo ejecutado
   * </p>
   *  @param grupoTrabajo  Grupo del trabajo ejecutado 
   */
    public void setGrupoTrabajo(java.lang.String grupoTrabajo)
    {
        this.grupoTrabajo = grupoTrabajo;
    }
    private java.util.Calendar fechaInicio;

  /**
   * <p>
   * Fecha de inicio de la ejecución del trabajo
   * </p>
   * @return java.util.Calendar
   */
    public java.util.Calendar getFechaInicio()
    {
        return this.fechaInicio;
    }

  /**
   * <p>
   * Fecha de inicio de la ejecución del trabajo
   * </p>
   *  @param fechaInicio  Fecha de inicio de la ejecución del trabajo 
   */
    public void setFechaInicio(java.util.Calendar fechaInicio)
    {
        this.fechaInicio = fechaInicio;
    }
    private java.util.Calendar fechaFin;

  /**
   * <p>
   * Fecha de fin del trabajo ejecutado
   * </p>
   * @return java.util.Calendar
   */
    public java.util.Calendar getFechaFin()
    {
        return this.fechaFin;
    }

  /**
   * <p>
   * Fecha de fin del trabajo ejecutado
   * </p>
   *  @param fechaFin  Fecha de fin del trabajo ejecutado 
   */
    public void setFechaFin(java.util.Calendar fechaFin)
    {
        this.fechaFin = fechaFin;
    }
    private java.lang.String usuario;

  /**
   * <p>
   * Identificador del usuario que ha ordenado la ejecución del
   * trabajo
   * </p>
   * @return java.lang.String
   */
    public java.lang.String getUsuario()
    {
        return this.usuario;
    }

  /**
   * <p>
   * Identificador del usuario que ha ordenado la ejecución del
   * trabajo
   * </p>
   *  @param usuario  Identificador del usuario que ha ordenado la ejecución del trabajo 
   */
    public void setUsuario(java.lang.String usuario)
    {
        this.usuario = usuario;
    }
    private java.lang.String estado;

  /**
   * <p>
   * Estado del trabajo ejecutado: OK, ERROR e INTERRUMPIDO.
   * </p>
   * @return java.lang.String
   */
    public java.lang.String getEstado()
    {
        return this.estado;
    }

  /**
   * <p>
   * Estado del trabajo ejecutado: OK, ERROR e INTERRUMPIDO.
   * </p>
   *  @param estado  Estado del trabajo ejecutado: OK, ERROR e INTERRUMPIDO. 
   */
    public void setEstado(java.lang.String estado)
    {
        this.estado = estado;
    }
    private java.util.Calendar fechaBaja;

  /**
   * <p>
   * El informe con fecha de baja distinta de nula no va a ser
   * mostrado
   * </p>
   * @return java.util.Calendar
   */
    public java.util.Calendar getFechaBaja()
    {
        return this.fechaBaja;
    }

  /**
   * <p>
   * El informe con fecha de baja distinta de nula no va a ser
   * mostrado
   * </p>
   *  @param fechaBaja  El informe con fecha de baja distinta de nula no va a ser mostrado 
   */
    public void setFechaBaja(java.util.Calendar fechaBaja)
    {
        this.fechaBaja = fechaBaja;
    }
    private java.lang.Long id;

    public java.lang.Long getId()
    {
        return this.id;
    }

    public void setId(java.lang.Long id)
    {
        this.id = id;
    }
  /**
   * <p>
   * Los trabajos ejecutados pueden estar compuestos de tareas más
   * pequeñas. Esta entidad registra los datos de los subtrabajos
   * dependientes de un trabajo padre.
   * </p>
   */
    private java.util.Collection registroTareaEjecutadas = new java.util.HashSet();

  /**
   * Getter of registroTareaEjecutadas.  
   * @return java.util.Collection  Los trabajos ejecutados pueden estar compuestos de tareas más pequeñas. Esta entidad registra los datos de los subtrabajos dependientes de un trabajo padre.
   */
    public java.util.Collection getRegistroTareaEjecutadas()
    {
        return this.registroTareaEjecutadas;
    }

  /**
   * Setter of registroTareaEjecutadas  
   *  @param registroTareaEjecutadas  Los trabajos ejecutados pueden estar compuestos de tareas más pequeñas. Esta entidad registra los datos de los subtrabajos dependientes de un trabajo padre. 
   */
    public void setRegistroTareaEjecutadas(java.util.Collection registroTareaEjecutadas)
    {
        this.registroTareaEjecutadas = registroTareaEjecutadas;
    }



    /**
     * Returns <code>true</code> if the argument is an TareaEjecutada instance and all identifiers for this entity
     * equal the identifiers of the argument entity. Returns <code>false</code> otherwise.
     *
     * @param object The object to compare
     * @return boolean
     */
    public boolean equals(Object object)
    {
        if (this == object)
        {
            return true;
        }
        if (!(object instanceof TareaEjecutada))
        {
            return false;
        }
        final TareaEjecutada that = (TareaEjecutada)object;
        if (this.id == null || that.id == null || !this.id.equals(that.id))
        {
            return false;
        }
        return true;
    }

    /**
     * Returns a hash code based on this entity's identifiers.
     * @return int
     */
    public int hashCode()
    {
        int hashCode = 0;
        hashCode = 29 * hashCode + (id == null ? 0 : id.hashCode());

        return hashCode;
    }

    /**
     * Constructs new instances of {@link es.pode.planificador.negocio.dominio.TareaEjecutada}.
     */
    public static final class Factory
    {
        /**
         * Constructs a new instance of {@link es.pode.planificador.negocio.dominio.TareaEjecutada}.
         * @return es.pode.planificador.negocio.dominio.TareaEjecutada
         */
        public static es.pode.planificador.negocio.dominio.TareaEjecutada newInstance()
        {
            return new es.pode.planificador.negocio.dominio.TareaEjecutadaImpl();
        }
    }

// HibernateEntity.vsl merge-point
}